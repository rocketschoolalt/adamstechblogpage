// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.
import { assert } from "../_util/assert.ts";
import * as streams from "../streams/conversion.ts";
import * as files from "./files.ts";
const DEFAULT_BUFFER_SIZE = 32 * 1024;
/**
 * Copy N size at the most. If read size is lesser than N, then returns nread
 * @param r Reader
 * @param dest Writer
 * @param size Read size
 */ export async function copyN(r, dest, size) {
    let bytesRead = 0;
    let buf = new Uint8Array(DEFAULT_BUFFER_SIZE);
    while(bytesRead < size){
        if (size - bytesRead < DEFAULT_BUFFER_SIZE) {
            buf = new Uint8Array(size - bytesRead);
        }
        const result = await r.read(buf);
        const nread = result ?? 0;
        bytesRead += nread;
        if (nread > 0) {
            let n = 0;
            while(n < nread){
                n += await dest.write(buf.slice(n, nread));
            }
            assert(n === nread, "could not write");
        }
        if (result === null) {
            break;
        }
    }
    return bytesRead;
}
/**
 * Read big endian 16bit short from BufReader
 * @param buf
 */ export async function readShort(buf) {
    const high = await buf.readByte();
    if (high === null) return null;
    const low = await buf.readByte();
    if (low === null) throw new Deno.errors.UnexpectedEof();
    return high << 8 | low;
}
/**
 * Read big endian 32bit integer from BufReader
 * @param buf
 */ export async function readInt(buf) {
    const high = await readShort(buf);
    if (high === null) return null;
    const low = await readShort(buf);
    if (low === null) throw new Deno.errors.UnexpectedEof();
    return high << 16 | low;
}
const MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
/**
 * Read big endian 64bit long from BufReader
 * @param buf
 */ export async function readLong(buf) {
    const high = await readInt(buf);
    if (high === null) return null;
    const low = await readInt(buf);
    if (low === null) throw new Deno.errors.UnexpectedEof();
    const big = BigInt(high) << 32n | BigInt(low);
    // We probably should provide a similar API that returns BigInt values.
    if (big > MAX_SAFE_INTEGER) {
        throw new RangeError("Long value too big to be represented as a JavaScript number.");
    }
    return Number(big);
}
/**
 * Slice number into 64bit big endian byte array
 * @param d The number to be sliced
 * @param dest The sliced array
 */ export function sliceLongToBytes(d, dest = Array.from({
    length: 8
})) {
    let big = BigInt(d);
    for(let i = 0; i < 8; i++){
        dest[7 - i] = Number(big & 255n);
        big >>= 8n;
    }
    return dest;
}
/** @deprecated Use readAll from https://deno.land/std/streams/conversion.ts instead. */ export const readAll = streams.readAll;
/** @deprecated Use readAllSync from https://deno.land/std/streams/conversion.ts instead. */ export const readAllSync = streams.readAllSync;
/** @deprecated Use writeAll from https://deno.land/std/streams/conversion.ts instead. */ export const writeAll = streams.writeAll;
/** @deprecated Use writeAllSync from https://deno.land/std/streams/conversion.ts instead. */ export const writeAllSync = streams.writeAllSync;
/** @deprecated Use iterateReader from https://deno.land/std/streams/conversion.ts instead. */ export const iter = streams.iterateReader;
/** @deprecated Use iterateReaderSync from https://deno.land/std/streams/conversion.ts instead. */ export const iterSync = streams.iterateReaderSync;
/** @deprecated Use copy from https://deno.land/std/streams/conversion.ts instead. */ export const copy = streams.copy;
/** @deprecated Use readRange from https://deno.land/std/io/files.ts instead. */ export const readRange = files.readRange;
/** @deprecated Use readRangeSync from https://deno.land/std/io/files.ts instead. */ export const readRangeSync = files.readRangeSync;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3N0ZEAwLjExOC4wL2lvL3V0aWwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTgtMjAyMSB0aGUgRGVubyBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuLi9fdXRpbC9hc3NlcnQudHNcIjtcbmltcG9ydCB0eXBlIHsgQnVmUmVhZGVyIH0gZnJvbSBcIi4vYnVmZmVyLnRzXCI7XG5pbXBvcnQgdHlwZSB7IFJlYWRlciwgV3JpdGVyIH0gZnJvbSBcIi4vdHlwZXMuZC50c1wiO1xuaW1wb3J0ICogYXMgc3RyZWFtcyBmcm9tIFwiLi4vc3RyZWFtcy9jb252ZXJzaW9uLnRzXCI7XG5pbXBvcnQgKiBhcyBmaWxlcyBmcm9tIFwiLi9maWxlcy50c1wiO1xuXG5jb25zdCBERUZBVUxUX0JVRkZFUl9TSVpFID0gMzIgKiAxMDI0O1xuXG4vKipcbiAqIENvcHkgTiBzaXplIGF0IHRoZSBtb3N0LiBJZiByZWFkIHNpemUgaXMgbGVzc2VyIHRoYW4gTiwgdGhlbiByZXR1cm5zIG5yZWFkXG4gKiBAcGFyYW0gciBSZWFkZXJcbiAqIEBwYXJhbSBkZXN0IFdyaXRlclxuICogQHBhcmFtIHNpemUgUmVhZCBzaXplXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb3B5TihcbiAgcjogUmVhZGVyLFxuICBkZXN0OiBXcml0ZXIsXG4gIHNpemU6IG51bWJlcixcbik6IFByb21pc2U8bnVtYmVyPiB7XG4gIGxldCBieXRlc1JlYWQgPSAwO1xuICBsZXQgYnVmID0gbmV3IFVpbnQ4QXJyYXkoREVGQVVMVF9CVUZGRVJfU0laRSk7XG4gIHdoaWxlIChieXRlc1JlYWQgPCBzaXplKSB7XG4gICAgaWYgKHNpemUgLSBieXRlc1JlYWQgPCBERUZBVUxUX0JVRkZFUl9TSVpFKSB7XG4gICAgICBidWYgPSBuZXcgVWludDhBcnJheShzaXplIC0gYnl0ZXNSZWFkKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgci5yZWFkKGJ1Zik7XG4gICAgY29uc3QgbnJlYWQgPSByZXN1bHQgPz8gMDtcbiAgICBieXRlc1JlYWQgKz0gbnJlYWQ7XG4gICAgaWYgKG5yZWFkID4gMCkge1xuICAgICAgbGV0IG4gPSAwO1xuICAgICAgd2hpbGUgKG4gPCBucmVhZCkge1xuICAgICAgICBuICs9IGF3YWl0IGRlc3Qud3JpdGUoYnVmLnNsaWNlKG4sIG5yZWFkKSk7XG4gICAgICB9XG4gICAgICBhc3NlcnQobiA9PT0gbnJlYWQsIFwiY291bGQgbm90IHdyaXRlXCIpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVzUmVhZDtcbn1cblxuLyoqXG4gKiBSZWFkIGJpZyBlbmRpYW4gMTZiaXQgc2hvcnQgZnJvbSBCdWZSZWFkZXJcbiAqIEBwYXJhbSBidWZcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWRTaG9ydChidWY6IEJ1ZlJlYWRlcik6IFByb21pc2U8bnVtYmVyIHwgbnVsbD4ge1xuICBjb25zdCBoaWdoID0gYXdhaXQgYnVmLnJlYWRCeXRlKCk7XG4gIGlmIChoaWdoID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgbG93ID0gYXdhaXQgYnVmLnJlYWRCeXRlKCk7XG4gIGlmIChsb3cgPT09IG51bGwpIHRocm93IG5ldyBEZW5vLmVycm9ycy5VbmV4cGVjdGVkRW9mKCk7XG4gIHJldHVybiAoaGlnaCA8PCA4KSB8IGxvdztcbn1cblxuLyoqXG4gKiBSZWFkIGJpZyBlbmRpYW4gMzJiaXQgaW50ZWdlciBmcm9tIEJ1ZlJlYWRlclxuICogQHBhcmFtIGJ1ZlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZEludChidWY6IEJ1ZlJlYWRlcik6IFByb21pc2U8bnVtYmVyIHwgbnVsbD4ge1xuICBjb25zdCBoaWdoID0gYXdhaXQgcmVhZFNob3J0KGJ1Zik7XG4gIGlmIChoaWdoID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgbG93ID0gYXdhaXQgcmVhZFNob3J0KGJ1Zik7XG4gIGlmIChsb3cgPT09IG51bGwpIHRocm93IG5ldyBEZW5vLmVycm9ycy5VbmV4cGVjdGVkRW9mKCk7XG4gIHJldHVybiAoaGlnaCA8PCAxNikgfCBsb3c7XG59XG5cbmNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuXG4vKipcbiAqIFJlYWQgYmlnIGVuZGlhbiA2NGJpdCBsb25nIGZyb20gQnVmUmVhZGVyXG4gKiBAcGFyYW0gYnVmXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkTG9uZyhidWY6IEJ1ZlJlYWRlcik6IFByb21pc2U8bnVtYmVyIHwgbnVsbD4ge1xuICBjb25zdCBoaWdoID0gYXdhaXQgcmVhZEludChidWYpO1xuICBpZiAoaGlnaCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGxvdyA9IGF3YWl0IHJlYWRJbnQoYnVmKTtcbiAgaWYgKGxvdyA9PT0gbnVsbCkgdGhyb3cgbmV3IERlbm8uZXJyb3JzLlVuZXhwZWN0ZWRFb2YoKTtcbiAgY29uc3QgYmlnID0gKEJpZ0ludChoaWdoKSA8PCAzMm4pIHwgQmlnSW50KGxvdyk7XG4gIC8vIFdlIHByb2JhYmx5IHNob3VsZCBwcm92aWRlIGEgc2ltaWxhciBBUEkgdGhhdCByZXR1cm5zIEJpZ0ludCB2YWx1ZXMuXG4gIGlmIChiaWcgPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICBcIkxvbmcgdmFsdWUgdG9vIGJpZyB0byBiZSByZXByZXNlbnRlZCBhcyBhIEphdmFTY3JpcHQgbnVtYmVyLlwiLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIE51bWJlcihiaWcpO1xufVxuXG4vKipcbiAqIFNsaWNlIG51bWJlciBpbnRvIDY0Yml0IGJpZyBlbmRpYW4gYnl0ZSBhcnJheVxuICogQHBhcmFtIGQgVGhlIG51bWJlciB0byBiZSBzbGljZWRcbiAqIEBwYXJhbSBkZXN0IFRoZSBzbGljZWQgYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlTG9uZ1RvQnl0ZXMoXG4gIGQ6IG51bWJlcixcbiAgZGVzdCA9IEFycmF5LmZyb208bnVtYmVyPih7IGxlbmd0aDogOCB9KSxcbik6IG51bWJlcltdIHtcbiAgbGV0IGJpZyA9IEJpZ0ludChkKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICBkZXN0WzcgLSBpXSA9IE51bWJlcihiaWcgJiAweGZmbik7XG4gICAgYmlnID4+PSA4bjtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cblxuLyoqIEBkZXByZWNhdGVkIFVzZSByZWFkQWxsIGZyb20gaHR0cHM6Ly9kZW5vLmxhbmQvc3RkL3N0cmVhbXMvY29udmVyc2lvbi50cyBpbnN0ZWFkLiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRBbGwgPSBzdHJlYW1zLnJlYWRBbGw7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIHJlYWRBbGxTeW5jIGZyb20gaHR0cHM6Ly9kZW5vLmxhbmQvc3RkL3N0cmVhbXMvY29udmVyc2lvbi50cyBpbnN0ZWFkLiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRBbGxTeW5jID0gc3RyZWFtcy5yZWFkQWxsU3luYztcbi8qKiBAZGVwcmVjYXRlZCBVc2Ugd3JpdGVBbGwgZnJvbSBodHRwczovL2Rlbm8ubGFuZC9zdGQvc3RyZWFtcy9jb252ZXJzaW9uLnRzIGluc3RlYWQuICovXG5leHBvcnQgY29uc3Qgd3JpdGVBbGwgPSBzdHJlYW1zLndyaXRlQWxsO1xuLyoqIEBkZXByZWNhdGVkIFVzZSB3cml0ZUFsbFN5bmMgZnJvbSBodHRwczovL2Rlbm8ubGFuZC9zdGQvc3RyZWFtcy9jb252ZXJzaW9uLnRzIGluc3RlYWQuICovXG5leHBvcnQgY29uc3Qgd3JpdGVBbGxTeW5jID0gc3RyZWFtcy53cml0ZUFsbFN5bmM7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGl0ZXJhdGVSZWFkZXIgZnJvbSBodHRwczovL2Rlbm8ubGFuZC9zdGQvc3RyZWFtcy9jb252ZXJzaW9uLnRzIGluc3RlYWQuICovXG5leHBvcnQgY29uc3QgaXRlciA9IHN0cmVhbXMuaXRlcmF0ZVJlYWRlcjtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaXRlcmF0ZVJlYWRlclN5bmMgZnJvbSBodHRwczovL2Rlbm8ubGFuZC9zdGQvc3RyZWFtcy9jb252ZXJzaW9uLnRzIGluc3RlYWQuICovXG5leHBvcnQgY29uc3QgaXRlclN5bmMgPSBzdHJlYW1zLml0ZXJhdGVSZWFkZXJTeW5jO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBjb3B5IGZyb20gaHR0cHM6Ly9kZW5vLmxhbmQvc3RkL3N0cmVhbXMvY29udmVyc2lvbi50cyBpbnN0ZWFkLiAqL1xuZXhwb3J0IGNvbnN0IGNvcHkgPSBzdHJlYW1zLmNvcHk7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIHJlYWRSYW5nZSBmcm9tIGh0dHBzOi8vZGVuby5sYW5kL3N0ZC9pby9maWxlcy50cyBpbnN0ZWFkLiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRSYW5nZSA9IGZpbGVzLnJlYWRSYW5nZTtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgcmVhZFJhbmdlU3luYyBmcm9tIGh0dHBzOi8vZGVuby5sYW5kL3N0ZC9pby9maWxlcy50cyBpbnN0ZWFkLiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRSYW5nZVN5bmMgPSBmaWxlcy5yZWFkUmFuZ2VTeW5jO1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLEVBQTBFLEFBQTFFLHdFQUEwRTtBQUMxRSxNQUFNLEdBQUcsTUFBTSxRQUFRLENBQW9CO0FBRzNDLE1BQU0sTUFBTSxPQUFPLE1BQU0sQ0FBMEI7QUFDbkQsTUFBTSxNQUFNLEtBQUssTUFBTSxDQUFZO0FBRW5DLEtBQUssQ0FBQyxtQkFBbUIsR0FBRyxFQUFFLEdBQUcsSUFBSTtBQUVyQyxFQUtHLEFBTEg7Ozs7O0NBS0csQUFMSCxFQUtHLENBQ0gsTUFBTSxn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